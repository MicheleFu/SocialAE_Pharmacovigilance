<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Metodo implementato per la tesi</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>





<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Metodo implementato per la tesi</h1>

<p>Il seguente metodo è stato sviluppato ricorrendo al linguaggio di programmazione R, versione 3.5.2 (2018-12-20).</p>

<p>Il materiale utilizzato è stato condiviso sulla piattaforma GitHub insieme agli script completi (con anche il codice per la pulizia dei database e l&#39;analisi descrittiva), ai risultati e ai plot per la visualizzazione. Si riportano qui solo le funzioni principali di calcolo delle misure di associazione (ROR) e disegno della Heatmap, e di creazione dei modelli di regressione lineare.</p>

<h2>Librerie utilizzate</h2>

<pre><code class="r">library(tidyverse)
library(cowplot)
library(superheat)
library(RColorBrewer)
</code></pre>

<h2>Calcolo delle misure di associazione</h2>

<pre><code class="r">Wrangle &lt;- function(df, D) {
  #
  # Argomenti:
  #   df  : Dataframe con tutte le segnalazioni già pulite
  #   D   : Lista dei principi attivi
  #
  # Risultato:
  #   Wrangle_df : Database contenente i dati riassuntivi
  #                 delle analisi di disproporzionalità
  Wrangle_df &lt;- data.frame(matrix(ncol = 12, nrow = 0))
  colnames(Wrangle_df) &lt;- c(&quot;Drug_Code&quot;, &quot;Drug_Name&quot;, &quot;AE&quot;, &quot;F_EA&quot;, &quot;F_nEA&quot;,
                            &quot;nF_EA&quot;,&quot;nF_nEA&quot;, &quot;ROR&quot;, &quot;s&quot;, &quot;ROR_m&quot;, &quot;ROR_M&quot;, &quot;IC&quot;)
  for (i in 1:length(AE_list)) {
    EA_Name &lt;- AE_list[i]
    print(EA_Name)
    x &lt;- subset(df, str_detect(Reactions, AE_list[i]))
    for (d in D) {
      D_Code &lt;- ATC$Code[ATC$Substance == d]
      y &lt;- subset(df,!str_detect(`Suspect Product Active Ingredients Code`,D_Code))
      if (sum(str_detect(x$`Suspect Product Active Ingredients Code`, D_Code))==0) {
        F_nEA &lt;- sum(str_detect(df$`Suspect Product Active Ingredients Code`, D_Code))
        nF_EA &lt;- sum(str_detect(y$Reactions,EA_Name))
        nF_nEA &lt;- sum(!str_detect(y$Reactions,EA_Name))
        new_row &lt;- list(D_Code, d, EA_Name, 0, F_nEA, nF_EA, nF_nEA, NA, NA, NA, NA, NA)
      } else {
        tab &lt;- table(str_detect(df$`Suspect Product Active Ingredients Code`, D_Code),
                     str_detect(df$Reactions, AE_list[i]))
        colnames(tab)[1] &lt;- &quot;nEA&quot; # other reactions
        colnames(tab)[2] &lt;- &quot;EA&quot;  # reaction e
        rownames(tab)[1] &lt;- &quot;nF&quot;  # other drugs
        rownames(tab)[2] &lt;- &quot;F&quot;   # drug d
        t &lt;- as.data.frame.matrix(tab)
        F_EA &lt;- t[&quot;F&quot;,&quot;EA&quot;]
        F_nEA &lt;- t[&quot;F&quot;,&quot;nEA&quot;]
        nF_EA &lt;- t[&quot;nF&quot;,&quot;EA&quot;]
        nF_nEA &lt;- t[&quot;nF&quot;,&quot;nEA&quot;]
        ROR_m &lt;- NA
        ROR_M &lt;- NA
        ROR &lt;- NA
        IC &lt;- NA
        s &lt;- NA
        if (F_EA&gt;=3) {
          ROR &lt;- F_EA * nF_nEA / nF_EA / F_nEA
          s &lt;- sqrt(1/F_EA + 1/F_nEA + 1/nF_EA + 1/nF_nEA)
          ROR_m &lt;- exp(log(ROR) - 1.96*s)
          ROR_M &lt;- exp(log(ROR) + 1.96*s)
          if (is.infinite(ROR)) {IC &lt;- &quot;[|Inf|]&quot;} else {
            ROR_m &lt;- round(ROR_m, digits = 1)
            ROR &lt;- round(ROR, digits = 1)
            ROR_M &lt;- round(ROR_M, digits = 1)
            IC &lt;- paste(&quot;[&quot;, ROR_m,
                        &quot;|&quot;, ROR, &quot;|&quot;,
                        ROR_M, &quot;]&quot;,
                        sep = &quot;&quot;)
          }
        }
        new_row &lt;- list(D_Code, d, EA_Name, F_EA, F_nEA, nF_EA, nF_nEA, ROR, s, ROR_m,
                        ROR_M, IC)
      }
      Wrangle_df[nrow(Wrangle_df)+1,] &lt;-  new_row
    }
  }
  return(Wrangle_df)
}
</code></pre>

<h2>Funzione per disegnare la Heatmap</h2>

<pre><code class="r">Create_Matrix &lt;- function(df, index) {
  m &lt;- matrix(ncol = length(AE_list), nrow = length(D_Code_list))
  rownames(m) &lt;- D_Code_list
  colnames(m) &lt;- AE_list
  for (e in AE_list) {
    x &lt;- subset(df, AE == e)
    for (d in D_Code_list){
      print(d)
      if (!is.na(x$ROR_m[x$Drug_Code == d])) {
        if(x$ROR_m[x$Drug_Code == d] &gt; 1) {
          m[d,e] = x[[index]][x$Drug_Code == d]
        }
      }
    }
  }
  onlyNAcolumns_idx &lt;- m %&gt;%
    is.na() %&gt;%
    apply(MARGIN = 2, FUN = all)
  m &lt;- m[,!onlyNAcolumns_idx]
  m &lt;- m[rowSums(is.na(m)) != ncol(m), ]
  m &lt;- m %&gt;%
    as.data.frame()
  m &lt;- setNames(cbind(rownames(m), m, row.names = NULL), c(&quot;Code&quot;,colnames(m)))
  m &lt;- m %&gt;%
    left_join(ATC, by = &quot;Code&quot;) %&gt;%
    select(Code, &quot;Substance&quot;, everything()) %&gt;%
    unite(Drug, c(Code, &quot;Substance&quot;), sep = &quot;: &quot;)
  return(m)
}

Print_Heatmap &lt;- function(df) {
  #
  # Argomenti:
  #   df  : Dataframe con i risultati delle analisi di disproporzionalità
  #
  # Risultato:
  #   Heatmap.png : Grafico che facilita la visualizzazione dei ROR
  Heatmatrix &lt;- Create_Matrix(df,&quot;ROR&quot;)
  Code_member &lt;- substr(Heatmatrix$Drug, start = 1, stop = 4)
  Heatmatrix &lt;- Heatmatrix %&gt;%
    remove_rownames() %&gt;%
    column_to_rownames(var = &quot;Drug&quot;) %&gt;%
    as.matrix()
  IC_matrix &lt;- Create_Matrix(df, &quot;IC&quot;)
  IC_matrix &lt;- IC_matrix %&gt;%
    remove_rownames() %&gt;%
    column_to_rownames(var = &quot;Drug&quot;) %&gt;%
    as.matrix()
  IC_matrix[is.na(IC_matrix)] &lt;- &quot;&quot;
  Heatmatrix[Heatmatrix[,] == &quot;Inf&quot;] &lt;- 100
  Heatmatrix[Heatmatrix[,] &gt; 100] &lt;- 100
  l &lt;- paste(&quot;Visualization/Heatmap_&quot;,deparse(substitute((df))),&quot;.png&quot;, sep = &quot;&quot;)
  png(l, height = 15000, width = 8000)
  superheat(Heatmatrix,
            heat.pal = c(&quot;white&quot;, &quot;red&quot;, &quot;#b35806&quot;,&quot;#542788&quot;),
            heat.pal.values = c(0, 0.1, 0.5, 1),
            heat.col.scheme = &quot;red&quot;,
            heat.lim = c(1,100),
            bottom.label.text.angle = 90,
            bottom.label.text.size = 10,
            bottom.label.size = 0.1,
            force.left.label = TRUE,
            left.label.text.size = 4,
            left.label.size = 0.4,
            force.grid.hline = TRUE,
            grid.hline.col = &quot;gray&quot;,
            grid.vline.col = &quot;gray&quot;,
            heat.na.col= &quot;white&quot;,
            X.text = IC_matrix,
            X.text.size = 3,
            left.label.text.alignment = &quot;right&quot;,
            pretty.order.rows = FALSE,
            membership.rows = Code_member,
            left.label = &quot;variable&quot;,
            row.title = &quot;Substance&quot;,
            row.title.size = 6,
            column.title = &quot;Adverse Event&quot;,
            column.title.size = 6)
  dev.off()
}
</code></pre>

<h2>Funzione per produrre i modelli di regressione lineare a partire dal pChEMBL</h2>

<pre><code class="r">LRM &lt;- function(df, PhD_df){
  #
  # Argomenti:
  #   df     : Dataframe con i risultati delle analisi di disproporzionalità
  #   PhD_df : Database contenente i dati di farmacodinamica
  #
  # Risultato:
  #   LRM.csv : Database contenente i dati riassuntivi
  #             dei modelli di regressione lineare
  #   LRM.pdf : Grafici rappresentanti i modelli di regressione lineare
  Targets_list &lt;- as.list(unique(PhD_df$`Target`))
  Action_list &lt;- as.list(unique(PhD_df$Action))
  df &lt;- df %&gt;%
    mutate(Drug_Family = substr(df$Drug_Code, start = 1, stop = 4))
  LRM_df &lt;- as.data.frame(matrix(nrow=0, ncol=8))
  colnames(LRM_df) &lt;- c(&quot;AE&quot;, &quot;Target&quot;,&quot;Action&quot;, &quot;Intercept&quot;, &quot;Slope&quot;, &quot;SE&quot;,
                        &quot;p_value&quot;, &quot;Pearson&quot;)
  pdf(&quot;Visualization/LRM.pdf&quot;)
  for (e in AE_list){
    x &lt;- subset(df, df$AE == e)
    x &lt;- subset(x, is.na(x$ROR) == FALSE)
    x &lt;- subset(x, is.infinite(x$ROR) == FALSE)
    for (t in Targets_list) {
      y &lt;- subset(PhD_df, `Target` == t) %&gt;%
        rename(Drug_Name = Substance)
      z1 &lt;- left_join(x,y, by =&quot;Drug_Name&quot;)
      z1 &lt;- subset(z1, is.na(z1$pCHEMBL) == FALSE)
      for (m in Action_list){
        z &lt;- subset(z1, z1$Action == m)
        if (dim(z)[1] &gt;= 4){
          Intercept &lt;- round(coefficients(summary(lm(z$ROR~z$pCHEMBL)))[1],2)
          Slope &lt;- round(coefficients(summary(lm(z$ROR~z$pCHEMBL)))[2],2)
          SE &lt;- round(coefficients(summary(lm(z$ROR~z$pCHEMBL)))[4],2)
          p_value &lt;- round(coefficients(summary(lm(z$ROR~z$pCHEMBL)))[8],6)
          P &lt;- cor.test(z$ROR, z$pCHEMBL, method=&quot;pearson&quot;)
          Pearson &lt;- round(P$estimate,2)
          LRM_df[nrow(LRM_df)+1,] &lt;- c(e, t, m, Intercept, Slope, SE, p_value, Pearson)
          if (p_value &lt;= 1){
            plot1 &lt;- ggplot(data = z, aes(x=z$pCHEMBL, y=z$ROR, main= paste(&quot;ROR ~ &quot;,
                                                                            t))) +
              geom_smooth(method =&quot;lm&quot;) +
              geom_point(aes(color = z$Drug_Family)) +
              xlab(&quot;pCHEMBL&quot;) +
              ylab(&quot;ROR&quot;)
            title &lt;- ggdraw() + draw_label(paste(e,&quot; ~ &quot;, t, &quot;[&quot;,m,&quot;]&quot;),
                                           fontface = &quot;bold&quot;)
            results &lt;- ggdraw() + draw_label(paste(&quot;Intercept: &quot;, Intercept,
                                                   &quot;     Slope: &quot;, Slope,
                                                   &quot;     SE: &quot;, SE,
                                                   &quot;     p-value: &quot;, p_value,
                                                   &quot;     Pearson: &quot;, Pearson), ,
                                             size = 10)
            plot2 &lt;- ggplot(data = z, aes(x=z$pCHEMBL, y=z$ROR, main= paste(&quot;ROR ~ &quot;,
                                                                            t))) +
              geom_smooth(aes(color = Drug_Family), method =&quot;lm&quot;) +
              geom_point(aes(color = Drug_Family)) +
              xlab(&quot;pCHEMBL&quot;) +
              ylab(NULL)
            legenda &lt;- get_legend(plot2)
            p &lt;- plot_grid(plot_grid(plot1 + theme(legend.position = &quot;none&quot;),
                                     plot2 + theme(legend.position = &quot;none&quot;),
                                     labels = &quot;AUTO&quot;,
                                     rel_widths = c(1,1), align = &quot;h&quot;),
                           legenda,
                           rel_widths = c(2,.3))
            print(plot_grid(title, p, results, ncol=1, rel_heights=c(0.1, 1, 0.1)))
          }
        }
      }
    }
  }
  dev.off()
  LRM_df &lt;- LRM_df %&gt;%
    arrange(p_value) %&gt;%
    mutate(Rank = rank(p_value))
  LRM_df &lt;- LRM_df %&gt;%
    mutate(BH20 = (Rank/nrow(LRM_df))*0.20) %&gt;%
    mutate(Sign20 = (p_value &lt;= BH20))
  write_csv2(LRM_df, &quot;Results/LRM.csv&quot;)
}
</code></pre>

<h2>Funzione per lo sviluppo dei modelli di regressione lineare dei soli DAA</h2>

<pre><code class="r">LRM &lt;- function(df, PhD_df){
  #
  # Argomenti:
  #   df     : Dataframe con i risultati delle analisi di disproporzionalità
  #   PhD_df : Database contenente i dati di farmacodinamica
  #
  # Risultato:
  #   ICD_occ.csv : Database contenente i dati riassuntivi
  #             dei modelli di regressione lineare
  #   ICD_LRM.pdf : Grafici rappresentanti i modelli di regressione lineare
  Targets_list &lt;- as.list(unique(PhD_df$Target))
  Action_list &lt;- as.list(unique(PhD_df$Action))
  LRM_df &lt;- as.data.frame(matrix(nrow=0, ncol=8))
  colnames(LRM_df) &lt;- c(&quot;AE&quot;, &quot;Target&quot;,&quot;Action&quot;, &quot;Intercept&quot;, &quot;Slope&quot;, &quot;SE&quot;,
                        &quot;p_value&quot;, &quot;Pearson&quot;)
  pdf(&quot;Visualization/ICD_LRM.pdf&quot;)
  for (e in AE_list){
    x &lt;- subset(df, df$AE == e)
    x &lt;- subset(x, is.na(x$ROR) == FALSE)
    x &lt;- subset(x, is.infinite(x$ROR) == FALSE)
    for (t in Targets_list) {
      y &lt;- subset(PhD_df, `Target` == t) %&gt;%
        rename(Drug_Name = Substance)
      z1 &lt;- left_join(x,y, by =&quot;Drug_Name&quot;)
      z1 &lt;- subset(z1, is.na(z1$Occupancy) == FALSE)
      for (m in Action_list){
        z &lt;- subset(z1, z1$Action == m)
        if (dim(z)[1] &gt;= 4){
          Intercept &lt;- round(coefficients(summary(lm(z$ROR~z$Occupancy)))[1],2)
          Slope &lt;- round(coefficients(summary(lm(z$ROR~z$Occupancy)))[2],2)
          SE &lt;- round(coefficients(summary(lm(z$ROR~z$Occupancy)))[4],2)
          p_value &lt;- round(coefficients(summary(lm(z$ROR~z$Occupancy)))[8],6)
          P &lt;- cor.test(z$ROR, z$Occupancy, method=&quot;pearson&quot;)
          Pearson &lt;- round(P$estimate,2)
          LRM_df[nrow(LRM_df)+1,] &lt;- c(e, t, m, Intercept, Slope, SE,
                                       p_value, Pearson)
          if (p_value &lt;= 1){
            plot1 &lt;- ggplot(data = z, aes(x=z$Occupancy, y=z$ROR,
                                          main= paste(&quot;ROR ~ &quot;, t))) +
              geom_smooth(method =&quot;lm&quot;) +
              geom_point(aes(color = z$Drug_Name)) +
              xlab(&quot;Occupancy&quot;) +
              ylab(&quot;ROR&quot;)
            title &lt;- ggdraw() + draw_label(paste(e,&quot; ~ &quot;, t, &quot;[&quot;,m,&quot;]&quot;),
                                           fontface = &quot;bold&quot;)
            results &lt;- ggdraw() + draw_label(paste(&quot;Intercept: &quot;, Intercept,
                                                   &quot;     Slope: &quot;, Slope,
                                                   &quot;     SE: &quot;, SE,
                                                   &quot;     p-value: &quot;, p_value,
                                                   &quot;     Pearson: &quot;, Pearson),
                                             size = 10)
            print(plot_grid(title, plot1, results, ncol=1, rel_heights=c(0.1, 1,
                                                                         0.1)))
          }
        }
      }
    }
  }
  dev.off()
  LRM_df &lt;- LRM_df %&gt;%
    arrange(p_value) %&gt;%
    mutate(Rank = rank(p_value))
  LRM_df &lt;- LRM_df %&gt;%
    mutate(BH20 = (Rank/nrow(LRM_df))*0.20) %&gt;%
    mutate(Sign20 = (p_value &lt;= BH20))
  ICD_occ_df &lt;- LRM_df
  write_csv2(ICD2_occ_df, &quot;Results/ICD_occ.csv&quot;)
}
</code></pre>

</body>

</html>
